<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
		<head>
				<title>Firera - intro</title>
				<meta charset="UTF-8">
				<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<link rel="stylesheet" href="guide.css" />
				<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css">
				<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
				<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
		</head>
		<body>
				<div id="content">
				<div id="in-content">
				<h1>Firera</h1>

Для початку Firera.js можна представити як FRP-бібліотеку, поруч з такими проектами, як Rx.js, cellx, modx, Bacon і т.п. В ній є т.зв. потоки івентів(event-streams), обчислювані комірки і багато інших стандартних атрибутів FRP. Однак Ф. практикує кардинально інший, декларативний, підхід для опису взаємозалежності між потоками даних. Внаслідок цього, бібілотека має кращу читабельність, широкі можливості для застосування ФП, кращу структурованість коду,і ще багато всяких переваг, але подивіться спочатку на код, і вам стане ясно.

Розглянемо простий приклад - форму додавання нового коментаря.
<code class="js">
var $root = $('#enter-name-and-email-form');
var simple_email_regex = /\S+@\S+\.\S+/;
var test_regex = (reg) => {
    return (str) => {
        return reg.test(str);
    }
}
var is_email_valid = test_regex(simple_email_regex);
var app = {
    $el: $root,
    email_valid: [is_email_valid, 'input.email|getval'],
    text_entered: [(a) => { return a.length > 2 }, 'textarea.text|getval'],
    form_valid: ['&&', 'email_valid', 'text_entered'],
    send_form: ['transist', '-form_valid', 'button.send|click'],
    do_something: ['transistAll', (email, name) => {
        // do something useful with entered data, e.g. AJAX request
    }, 'send_form', '-input.email|getval', '-textarea.text|getval'],
};
Firera({
    __root: app
})
</code>
Розібравши цей приклад, ви зрозумієте 80% бібліотеки(а на розбір інших 20% доведеться витратити ще 80% часу, так-так...).
Основна одиниця Ф. - це грід, тобто, згрупований набір взаємопов"язаних комірок(потоків даних). Як бачите, грід являє собою простий об"єкт(POJO), передавши який в глобальну функцію Firera, ми створимо інстанс нашого застосунку. Такий підхід має багато переваг, наприклад, ми можемо легко організувати "наслідування" і "домішки" між різними грідами за допомогою простих методів накшталт Object.assign, але про це потім.
Отже, які типи комірок є в Ф. і як вони оголошуються?
<code>
    $el: $root,
</code>
Це - найпростіший тип - комірка із статичним значенням. Правило дуже просте: усе, що ви запишете в правій частині гріда, буде інтерпретовано як буквальне значення, окрім масиву.
<code>
{
    sense: 42, // все ок, це буде просто число 42
    name: 'Carl', // просто строчка
    fib: [0, 1, 1, 2, 3, 5, 8], // ПОМИЛКА! 
    fib: ['just', [0, 1, 1, 2, 3, 5, 8]], // ось так пишуться масиви, якщо ви не хочете, щоб фреймворк їх сприйняв за свої конструкції
    name: ['just', 'Carl'], // так теж можна. Більш багатослівно, але підходить для випадку, коли ви не впевнені в типі змінної
}
</code>
Йдемо далі!
<code>
    email_valid: [is_email_valid, 'input.email|getval'],
</code>
Ось в цьому - вся суть бібліотеки. email_valid є коміркою, яка обраховується на основі значення іншої комірки('input.email|getval'). Записавши 'input.email|getval', ми уже створюємо комірку, потік даних якої означає той текст, який буде вводитись в input. Це один із прикладів вищезгаданого "декларативного підходу". Тут '.input.email' - це селектор(при чому, він може бути як завгодно складним, з пробілами і т.п.), а 'getval' - т.зв. "аспект", який вказує, яка саме характеристика ДОМ-вузла буде використана для створення потоку даних.
is_email_valid - функція, яка буде перевіряти передану їй строчку на відповідність регулярному виразу.
Значення комірки email_valid буде обраховуватись як результат застосування функції is_email_valid до значення комірки 'input.email|getval'. В Ф. застосовується префіксна нотація(знайома по таким мовам, як, наприклад, Lisp): спочатку йде функція, далі її аргументи. Таким чином, ви можете застосовувати чисті функції для опису взаємозв"язку між комірками.
І тут ми підходимо до головного, принципового моменту, який лежить в основі усієї філософії Ф.
**Значення, які залежні від потоків даних є також потоками даних!**
В більшості туторіалів по ФРП наводиться його використання для абстрагування речей, які інтуїтивно виглядають як потоки даних: наприклад, введена юзером інформація, кліки тощо. Однак, наприклад, стан форми - валідна вона чи ні - не виглядає як потік даних з першого погляду, чи не так? Але оскільки він залежний від потоків даних, він також є потоком даних. Розглянемо на таблиці, що показує значення різних комірок по мірі того, як юзер вводить дані в форму.

<table class="tbl">
<tr><td> Поле input.email        </td><td> Комірка "input.email|getval" </td><td> Комірка "is_email_valid"  </td></tr>
<tr><td> m     </td><td> m </td><td> false </td></tr>
<tr><td> me      </td><td>  me  </td><td>   false </td></tr>
<tr><td> me@ </td><td> me@    </td><td>    false </td></tr>
<tr><td> me@e </td><td> me@e    </td><td>    false </td></tr>
<tr><td> me@ex </td><td> me@ex    </td><td>    false </td></tr>
<tr><td> me@ex. </td><td> me@ex.    </td><td>    false </td></tr>
<tr><td> me@ex.c </td><td> me@ex.c    </td><td>    true </td></tr>
<tr><td> me@ex.co </td><td> me@ex.co    </td><td>    true </td></tr>
<tr><td> me@ex.com </td><td> me@ex.com    </td><td>    true </td></tr>
</table>

Як бачите, "is_email_valid" є теж потоком даних, однак в процесі вводу мейла його значення зміниться лише один раз - тоді, коли імейл стане валідним. Те саме і з наступною коміркою:
<code>
    text_entered: [(a) => { return a.length > 2 }, 'textarea.text|getval'],
</code>
Ми використовуємо чисту функцію, результат виконання якої зі значенням комірки 'textarea.text|getval' буде означати, чи ввів юзер якісь дані в поле name.
Як ви помічаєте, Ф. схиляє вас до широкого застосування чистих функцій, що дає можливість використовувати весь арсенал методології ФП. Наприклад, фанатичні прихильники ФП могли б написати замість функції
<code>
(a) => { return a.length > 2 }
</code>
наступний код:
<code>
var prop = (a) => {
	return (b) => {
		return b[a];
	}
}
var gt = (a) => {
	return (b) => {
		return b > a;
	}
}
var len_gt_2 = _.flow(prop(length), gt(2));
</code>
Як бачите, тут і карінг, і композиція функцій, усі смачненькі штучки)
Комірка text_entered буде приймати булеві значення в залежності від того, що ввів юзер.
<code>
    form_valid: ['&&', 'email_valid', 'text_entered'],
</code>
Вся форма буде валідною тоді, коли будуть валідні дані в полях email та name.
Отже, ми створюємо ще одну комірку, яка буде означати валідність усієї форми, станеться це тільки тоді, коли обидві інші комірки матимуть значення true. '&&' - функція із стандартної бібліотеки F. Однак не лякайтесь, вам не доведеться вчити багато нового, в даному випадку еквівалентним записом було б:
<code>
    form_valid: [(a, b) => a && b, 'email_valid', 'text_entered'],
</code>
Далі нам потрібно визначити подію, коли форма буде готова до відправки. Це станеться тоді, коли юзер клікнув по кнопці "Відправити" і форма в цей момент була валідною. Для відображення цього взаємозв"язку використаємо функцію transist з стандартної бібліотеки: вона повертає свій другий аргумент, якщо перший = true, і false у іншому випадку.
<code>
    send_form: ['transist', '-form_valid', 'button.send|click'],
</code>
Однак виникає питання, навіщо перед form_valid стоїь знак мінус? Щоб зрозуміти це, потрібно поглянути на принципи FRP.
Нехай у нас є приклад:
<code>
var app = Firera({__root: {
    a: 30,
    b: 12,
    c: [(a, b) => a + b, 'a', 'b']
}})
// перевіримо значення "с"
app.get('c'); // 42

app.set('b', 10);
app.get('c'); // 40

app.set('a', 1);
app.get('c'); // 11
</code>
(ви вже помітили, наскільки фірера-код читабельніший за своїх імперативних аналогів, якщо зрозуміти його принцип?)
Це базовий приклад, з якого починають вивчати суть frp. Головний момент тут в тому, що зміна в кожній із комірок-аргументів(a, b) буде викликати перерахунок значення c. Однак така поведінка не завжди потрібна.
У нашому прикладі, подія send_form має статись тільки тоді, коли відбувається зміна в комірці 'button.send|click', тобто, коли юзер, фактично, клікає по кнопці. Якщо ж зміна відбудеться в комірці 'form_valid', ми не повинні нічого робити, т.як само по собі те, що форма стала валідною - не привід для її відправки ;) Для таких ситуацій в Ф. є механізм "пасивного слухання": значення змінної буде обраховуватись, однак зміни в цьому значенні не призведуть до перерахування в залежних комірках. В синтаксисі пасивне слухання позначається мінусом перед іменем комірки-аргумента.
Застосовувати його треба тільки тоді, коли ви знаєте, навіщо це робите. Наприклад, такий код буде працювати погано:
<code>
var app = Firera({__root: {
    a: 30,
    b: 12,
    c: [(a, b) => a + b, '-a', 'b']
}})
// перевіримо значення "с"
app.get('c'); // 42

app.set('b', 10);
app.get('c'); // 40

app.set('a', 1);
app.get('c'); // 40! значення не змінилось, т.як ми слухали "а" пасивно, і його зміна не спричинила перерахунку результату!
</code>
Остання строчка може робити корисну роботу при відправці форми:
<code>
    do_something: ['transistAll', (email, name) => {
        // do something useful with entered data, e.g. make an AJAX request
    }, 'send_form', 'input.email|getval', 'textarea.text|getval'],
</code>
Принцип роботи transistAll дещо інший: результатом є застосування функції до значень аргументів, починаючи з другого, якщо перший аргумент = true. Аби не робити зайвих перевірок, ми будемо слухати активно тільки зміни в потоці 'send_form', слухаючи інші потоки пасивно.

Ф., в певному розумінні, перевертає в вашому застосунку усе з ніг на голову. Зазвичай ми мислимо так "від причини - наслідок". Наприклад, "юзер клікнув по кнопці, отже, ми повинні зробити А, Б, і Ц". З Ф. вам доведеться мислити навпаки: "Є подія А. За яких умов вона настає? Вона настає за умов Б, Ц, і Д".

Другий момент - інкоил набагато простіше мислити станами, аніж змінами. Наприклад, нам потрібно додати показ ерор меседжа, якщо юзер ввів некоректний мейл. Припустимо, що у нас в хтмлі є блок .error-msg.email, який містить в собі це повідомлення, однак він прихований. Наша задача - показати його, якщо буде введений невалідний мейл і приховати, коли він стане валідним.
<code>
var app = {
    $el: $root,
    email_valid: [is_email_valid, 'input.email|getval'],
    text_entered: [(a) => { return a.length > 2 }, 'textarea.text|getval'],
    form_valid: ['&&', 'email_valid', 'text_entered'],
    send_form: ['transist', '-form_valid', 'button.send|click'],
    '.error-msg.email|display': ['!', 'email_valid'],
    do_something: ['transistAll', (email, name) => {
        // do something useful with entered data, e.g. AJAX request
    }, 'send_form', '-input.email|getval', '-textarea.text|getval'],
};
</code>
Божествена простота! В імперативному царстві такий взаємозв"язок ми б описали приблизно так: "якщо імейл змінюється, і стає невалідним, то показати ерор меседж. Якщо ж він стає валідним, а перед цим був невалідним, то приховати ерор меседж". Як бачите, у декларативному царстві це все робиться набагато легше, простіше і ясніше. 
Вбудована функція Ф. "!" означає, як ви можете здогадатись, заперечення і еквівалентна (a) => !a;
Однак, ми упустили один момент: ерор меседж треба показувати не раніше, аніж юзер закінчить введення. Тобто, вже після того, як відбудеться хоча б одна подія blur. Тож змінимо наш код, використовуючи вже відому функцію transist:
<code>
    '.error-msg.email|display': ['transist', '.error-msg.email|blur', ['!', 'email_valid']],
</code>
Тут ви бачите ще одну особливість синтаксису - вкладені Ф-вирази.(Ф-виразом називаємо ось ці масиви, які слугують для опису залежності чарунки). Замість того, щоб створювати окрему комірку, яка б описувалась виразом ['!', 'email_valid'], ми можемо просто вставити цей вираз в потрібному місці.
Поки юзер не зробить жодної blur-події, значення комірки '.error-msg.email|blur' буде дорівнювати undefined, таким чином, відображення не буде змінюватись. Після першого ж blur івенту значенням комірки '.error-msg.email|blur' стане сам об"єкт цього івенту, це буде truthy-значення, отже, транзистор спрацює :)








				</div></div>
				<script>
						$(document).ready(function() {
								$('code').each(function(i, block) {
										hljs.highlightBlock(block);
								});
						});
				</script>
		</body>
</html>
